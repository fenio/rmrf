name: 'rm-rf'
description: 'Runner Maintenance: Reclaim Filesystem - Reclaim disk space on GitHub runners'
author: 'fenio'

branding:
  icon: 'trash-2'
  color: 'red'

inputs:
  remove-android:
    description: 'Remove Android SDK (~12GB)'
    required: false
    default: 'true'
  remove-dotnet:
    description: 'Remove .NET SDK (~2GB)'
    required: false
    default: 'true'
  remove-haskell:
    description: 'Remove GHC/Haskell (~2GB)'
    required: false
    default: 'true'
  remove-boost:
    description: 'Remove Boost (~1GB)'
    required: false
    default: 'true'
  remove-swift:
    description: 'Remove Swift (~1.5GB)'
    required: false
    default: 'true'
  remove-codeql:
    description: 'Remove CodeQL (~1GB)'
    required: false
    default: 'true'
  remove-hostedtoolcache:
    description: 'Remove cached tool versions - Go, Node.js, Python, Ruby, etc. (~8GB)'
    required: false
    default: 'false'
  remove-docker-images:
    description: 'Remove Docker images (~4GB)'
    required: false
    default: 'false'
  nuke:
    description: 'Nuke additional bloat: browsers, databases, cloud CLIs, build tools - experimental'
    required: false
    default: 'false'
  merge-disks:
    description: 'Merge root and /mnt into single LVM volume'
    required: false
    default: 'false'
  use-btrfs:
    description: 'Use Btrfs with zstd compression (requires merge-disks: true)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    # ============================================
    # PHASE 1: Record initial disk state
    # ============================================
    - name: Record initial disk state
      shell: bash
      run: |
        echo "============================================"
        echo "  rmrf - Initial Disk State"
        echo "============================================"
        echo ""
        df -h
        echo ""
        
        # Save initial values for summary
        echo "INITIAL_ROOT_AVAIL=$(df / --output=avail -BG | tail -1 | tr -d ' G')" >> $GITHUB_ENV
        echo "INITIAL_ROOT_USED=$(df / --output=used -BG | tail -1 | tr -d ' G')" >> $GITHUB_ENV
        
        if mountpoint -q /mnt 2>/dev/null; then
          echo "INITIAL_MNT_AVAIL=$(df /mnt --output=avail -BG | tail -1 | tr -d ' G')" >> $GITHUB_ENV
          echo ">>> /mnt is mounted ($(df -h /mnt --output=size | tail -1 | tr -d ' ') total, $(df -h /mnt --output=avail | tail -1 | tr -d ' ') available)"
        fi

    # ============================================
    # PHASE 2: Install rmz for fast deletion
    # ============================================
    - name: Install rmz
      shell: bash
      run: |
        echo ">>> Installing rmz (fast rm alternative)..."
        curl -sL https://github.com/SUPERCILEX/fuc/releases/download/3.1.1/x86_64-unknown-linux-gnu-rmz -o /tmp/rmz
        chmod +x /tmp/rmz
        echo "rmz installed successfully"

    # ============================================
    # PHASE 3: Remove bloat
    # ============================================
    - name: Remove bloat
      shell: bash
      env:
        REMOVE_ANDROID: ${{ inputs.remove-android }}
        REMOVE_DOTNET: ${{ inputs.remove-dotnet }}
        REMOVE_HASKELL: ${{ inputs.remove-haskell }}
        REMOVE_BOOST: ${{ inputs.remove-boost }}
        REMOVE_SWIFT: ${{ inputs.remove-swift }}
        REMOVE_CODEQL: ${{ inputs.remove-codeql }}
        REMOVE_HOSTEDTOOLCACHE: ${{ inputs.remove-hostedtoolcache }}
        REMOVE_DOCKER: ${{ inputs.remove-docker-images }}
      run: |
        echo "============================================"
        echo "  Removing bloat..."
        echo "============================================"
        echo ""
        
        paths=()
        
        if [[ "$REMOVE_ANDROID" == "true" ]]; then
          echo "- Marking Android SDK for removal"
          paths+=("/usr/local/lib/android")
        fi
        
        if [[ "$REMOVE_DOTNET" == "true" ]]; then
          echo "- Marking .NET SDK for removal"
          paths+=("/usr/share/dotnet")
        fi
        
        if [[ "$REMOVE_HASKELL" == "true" ]]; then
          echo "- Marking Haskell/GHC for removal"
          [[ -d "/opt/ghc" ]] && paths+=("/opt/ghc")
          [[ -d "/usr/local/.ghcup" ]] && paths+=("/usr/local/.ghcup")
        fi
        
        if [[ "$REMOVE_BOOST" == "true" ]]; then
          echo "- Marking Boost for removal"
          paths+=("/usr/local/share/boost")
        fi
        
        if [[ "$REMOVE_SWIFT" == "true" ]]; then
          echo "- Marking Swift for removal"
          paths+=("/usr/share/swift")
        fi
        
        if [[ "$REMOVE_CODEQL" == "true" ]]; then
          echo "- Marking CodeQL for removal"
          [[ -d "/opt/hostedtoolcache/CodeQL" ]] && paths+=("/opt/hostedtoolcache/CodeQL")
        fi
        
        if [[ "$REMOVE_HOSTEDTOOLCACHE" == "true" ]]; then
          echo "- Marking hosted tool cache for removal (Go, Node.js, Python, Ruby, etc.)"
          [[ -d "/opt/hostedtoolcache" ]] && paths+=("/opt/hostedtoolcache")
        fi
        
        echo ""
        
        if [[ ${#paths[@]} -gt 0 ]]; then
          echo "Removing ${#paths[@]} directories with rmz..."
          echo "Paths: ${paths[*]}"
          echo ""
          
          # Filter to only existing paths
          existing_paths=()
          for p in "${paths[@]}"; do
            if [[ -e "$p" ]]; then
              existing_paths+=("$p")
            else
              echo "Skipping non-existent: $p"
            fi
          done
          
          if [[ ${#existing_paths[@]} -gt 0 ]]; then
            time sudo /tmp/rmz "${existing_paths[@]}"
            echo ""
            echo "Removal complete!"
          else
            echo "No paths to remove."
          fi
        else
          echo "No directories marked for removal."
        fi
        
        # Docker images handled separately
        if [[ "$REMOVE_DOCKER" == "true" ]]; then
          echo ""
          echo "Removing Docker images..."
          docker system prune -af || true
        fi
        
        echo ""

    # ============================================
    # PHASE 3b: Nuke packages (experimental)
    # ============================================
    - name: Nuke packages
      if: ${{ inputs.nuke == 'true' }}
      shell: bash
      run: |
        echo "============================================"
        echo "  Nuking additional bloat..."
        echo "============================================"
        echo ""
        
        # Collect all paths to nuke
        nuke_paths=()
        
        # Browsers
        echo "=== Browsers ==="
        [[ -d "/opt/google/chrome" ]] && nuke_paths+=("/opt/google/chrome") && echo ">>> Chrome"
        [[ -d "/opt/microsoft/msedge" ]] && nuke_paths+=("/opt/microsoft/msedge") && echo ">>> Edge (msedge)"
        [[ -d "/opt/microsoft/edge" ]] && nuke_paths+=("/opt/microsoft/edge") && echo ">>> Edge"
        [[ -d "/usr/lib/firefox" ]] && nuke_paths+=("/usr/lib/firefox") && echo ">>> Firefox"
        [[ -d "/usr/lib/chromium-browser" ]] && nuke_paths+=("/usr/lib/chromium-browser") && echo ">>> Chromium"
        [[ -d "/usr/local/share/chromium" ]] && nuke_paths+=("/usr/local/share/chromium") && echo ">>> Chromium (local)"
        
        # Cloud CLIs
        echo ""
        echo "=== Cloud CLIs ==="
        [[ -d "/usr/lib/google-cloud-sdk" ]] && nuke_paths+=("/usr/lib/google-cloud-sdk") && echo ">>> Google Cloud SDK"
        [[ -d "/usr/local/aws-cli" ]] && nuke_paths+=("/usr/local/aws-cli") && echo ">>> AWS CLI"
        [[ -d "/usr/local/aws-sam-cli" ]] && nuke_paths+=("/usr/local/aws-sam-cli") && echo ">>> AWS SAM CLI"
        [[ -d "/usr/local/sessionmanagerplugin" ]] && nuke_paths+=("/usr/local/sessionmanagerplugin") && echo ">>> AWS Session Manager"
        # Azure CLI directories (versioned)
        for d in /usr/share/az_*; do
          [[ -d "$d" ]] && nuke_paths+=("$d") && echo ">>> Azure CLI at $d"
        done
        [[ -d "/opt/az" ]] && nuke_paths+=("/opt/az") && echo ">>> Azure CLI (opt)"
        
        # Databases
        echo ""
        echo "=== Databases ==="
        [[ -d "/usr/lib/postgresql" ]] && nuke_paths+=("/usr/lib/postgresql") && echo ">>> PostgreSQL lib"
        [[ -d "/usr/share/postgresql" ]] && nuke_paths+=("/usr/share/postgresql") && echo ">>> PostgreSQL share"
        [[ -d "/var/lib/postgresql" ]] && nuke_paths+=("/var/lib/postgresql") && echo ">>> PostgreSQL data"
        [[ -d "/usr/lib/mysql" ]] && nuke_paths+=("/usr/lib/mysql") && echo ">>> MySQL lib"
        [[ -d "/usr/share/mysql" ]] && nuke_paths+=("/usr/share/mysql") && echo ">>> MySQL share"
        [[ -d "/var/lib/mysql" ]] && nuke_paths+=("/var/lib/mysql") && echo ">>> MySQL data"
        
        # Languages/Runtimes
        echo ""
        echo "=== Languages/Runtimes ==="
        # Julia
        for d in /usr/local/julia*/; do
          [[ -d "$d" ]] && nuke_paths+=("$d") && echo ">>> Julia at $d"
        done
        # Miniconda
        [[ -d "/usr/share/miniconda" ]] && nuke_paths+=("/usr/share/miniconda") && echo ">>> Miniconda"
        # Rust toolchains (multiple locations)
        [[ -d "/home/runner/.rustup" ]] && nuke_paths+=("/home/runner/.rustup") && echo ">>> Rust (runner)"
        [[ -d "/home/packer/.rustup" ]] && nuke_paths+=("/home/packer/.rustup") && echo ">>> Rust (packer)"
        [[ -d "/etc/skel/.rustup" ]] && nuke_paths+=("/etc/skel/.rustup") && echo ">>> Rust (skel)"
        [[ -d "/usr/local/.rustup" ]] && nuke_paths+=("/usr/local/.rustup") && echo ">>> Rust (local)"
        # Cargo
        [[ -d "/home/runner/.cargo" ]] && nuke_paths+=("/home/runner/.cargo") && echo ">>> Cargo (runner)"
        [[ -d "/home/packer/.cargo" ]] && nuke_paths+=("/home/packer/.cargo") && echo ">>> Cargo (packer)"
        [[ -d "/etc/skel/.cargo" ]] && nuke_paths+=("/etc/skel/.cargo") && echo ">>> Cargo (skel)"
        
        # Build tools
        echo ""
        echo "=== Build Tools ==="
        # Gradle
        for d in /usr/share/gradle-*/; do
          [[ -d "$d" ]] && nuke_paths+=("$d") && echo ">>> Gradle at $d"
        done
        # Kotlin
        [[ -d "/usr/share/kotlinc" ]] && nuke_paths+=("/usr/share/kotlinc") && echo ">>> Kotlin"
        # Maven
        for d in /usr/share/apache-maven-*/; do
          [[ -d "$d" ]] && nuke_paths+=("$d") && echo ">>> Maven at $d"
        done
        # LLVM versions
        for d in /usr/lib/llvm-*/; do
          [[ -d "$d" ]] && nuke_paths+=("$d") && echo ">>> LLVM at $d"
        done
        
        # Other bloat
        echo ""
        echo "=== Other ==="
        # Minikube
        [[ -f "/usr/local/bin/minikube" ]] && nuke_paths+=("/usr/local/bin/minikube") && echo ">>> Minikube"
        # Runner cache (actions-runner tarballs)
        [[ -d "/opt/runner-cache" ]] && nuke_paths+=("/opt/runner-cache") && echo ">>> Runner cache"
        # PowerShell modules
        [[ -d "/usr/local/share/powershell" ]] && nuke_paths+=("/usr/local/share/powershell") && echo ">>> PowerShell modules"
        # Homebrew
        [[ -d "/home/linuxbrew" ]] && nuke_paths+=("/home/linuxbrew") && echo ">>> Linuxbrew"
        # Packer home
        [[ -d "/home/packer" ]] && nuke_paths+=("/home/packer") && echo ">>> Packer home"
        # Node version manager
        [[ -d "/usr/local/n" ]] && nuke_paths+=("/usr/local/n") && echo ">>> Node version manager"
        # Java VMs (careful - may break things)
        [[ -d "/usr/lib/jvm" ]] && nuke_paths+=("/usr/lib/jvm") && echo ">>> Java VMs"
        
        echo ""
        
        # Remove duplicates and nuke
        if [[ ${#nuke_paths[@]} -gt 0 ]]; then
          readarray -t unique_paths < <(printf '%s\n' "${nuke_paths[@]}" | sort -u)
          echo "Nuking ${#unique_paths[@]} directories..."
          for p in "${unique_paths[@]}"; do
            echo "  - $p"
          done
          echo ""
          sudo /tmp/rmz "${unique_paths[@]}" 2>/dev/null || true
          echo "Nuke complete!"
        else
          echo "No packages found to nuke."
        fi
        
        echo ""

    # ============================================
    # PHASE 4: Merge disks (optional)
    # ============================================
    - name: Merge disks into LVM volume
      if: ${{ inputs.merge-disks == 'true' }}
      shell: bash
      env:
        USE_BTRFS: ${{ inputs.use-btrfs }}
      run: |
        echo "============================================"
        echo "  Merging disks into LVM volume..."
        echo "============================================"
        echo ""
        
        set -e  # Exit on error
        
        # Install LVM tools if not present
        if ! command -v pvcreate &> /dev/null; then
          echo ">>> Installing LVM tools..."
          sudo apt-get update -qq
          sudo apt-get install -y -qq lvm2
        else
          echo ">>> LVM tools already installed"
        fi
        
        if [[ "$USE_BTRFS" == "true" ]]; then
          if ! command -v mkfs.btrfs &> /dev/null; then
            echo ">>> Installing Btrfs tools..."
            [[ -f /var/lib/apt/lists/lock ]] || sudo apt-get update -qq
            sudo apt-get install -y -qq btrfs-progs
          else
            echo ">>> Btrfs tools already installed"
          fi
        fi
        
        # Disable swap
        echo ""
        echo ">>> Disabling swap..."
        sudo swapoff -a || true
        
        # Unmount /mnt
        echo ">>> Unmounting /mnt..."
        # Get the device for /mnt before unmounting
        MNT_DEVICE=$(df /mnt --output=source | tail -1)
        echo ">>> /mnt is on device: $MNT_DEVICE"
        sudo umount /mnt || true
        
        # Calculate loopback size (80% of available root space)
        avail_kb=$(df / --output=avail | tail -1 | tr -d ' ')
        avail_gb=$((avail_kb / 1024 / 1024))
        loop_size=$((avail_gb * 80 / 100))
        
        # Ensure minimum size of 10GB
        if [[ $loop_size -lt 10 ]]; then
          loop_size=10
        fi
        
        echo ""
        echo ">>> Available space on root: ${avail_gb}GB"
        echo ">>> Creating ${loop_size}GB loopback file..."
        
        # Create loopback file
        sudo fallocate -l ${loop_size}G /space.img
        
        # Find available loop device
        loop_dev=$(sudo losetup -f)
        echo ">>> Using loop device: $loop_dev"
        sudo losetup "$loop_dev" /space.img
        
        # Create LVM physical volumes (force to overwrite existing signatures)
        echo ""
        echo ">>> Creating LVM physical volumes..."
        sudo pvcreate -ff -y "$MNT_DEVICE"
        sudo pvcreate -ff -y "$loop_dev"
        
        # Create volume group
        echo ">>> Creating volume group 'workspace'..."
        sudo vgcreate workspace "$MNT_DEVICE" "$loop_dev"
        
        # Create logical volume
        echo ">>> Creating logical volume 'work'..."
        sudo lvcreate -l 100%FREE -n work workspace
        
        # Show LVM info
        echo ""
        echo ">>> LVM configuration:"
        sudo vgdisplay workspace
        
        # Format the volume
        echo ""
        if [[ "$USE_BTRFS" == "true" ]]; then
          echo ">>> Formatting as Btrfs with zstd compression..."
          sudo mkfs.btrfs -f /dev/workspace/work
          
          echo ">>> Mounting at /home/runner/work..."
          sudo mount -o compress=zstd /dev/workspace/work /home/runner/work
        else
          echo ">>> Formatting as ext4..."
          sudo mkfs.ext4 -F /dev/workspace/work
          
          echo ">>> Mounting at /home/runner/work..."
          sudo mount /dev/workspace/work /home/runner/work
        fi
        
        # Create swap file on root filesystem
        echo ">>> Creating 4GB swap file on /..."
        sudo fallocate -l 4G /swap.img
        sudo chmod 600 /swap.img
        sudo mkswap /swap.img
        sudo swapon /swap.img
        
        # Fix ownership
        echo ">>> Fixing ownership..."
        sudo chown -R runner:runner /home/runner/work
        
        echo ""
        echo ">>> Disk merge complete!"

    # ============================================
    # PHASE 5: Summary
    # ============================================
    - name: Summary
      shell: bash
      env:
        MERGE_DISKS: ${{ inputs.merge-disks }}
      run: |
        echo ""
        echo "============================================"
        echo "  rmrf - Summary"
        echo "============================================"
        echo ""
        
        df -h
        echo ""
        
        # Calculate space gained
        FINAL_ROOT_AVAIL=$(df / --output=avail -BG | tail -1 | tr -d ' G')
        FINAL_ROOT_USED=$(df / --output=used -BG | tail -1 | tr -d ' G')
        
        ROOT_FREED=$((FINAL_ROOT_AVAIL - INITIAL_ROOT_AVAIL))
        
        echo "============================================"
        echo "  Space Report"
        echo "============================================"
        echo ""
        echo "Root filesystem (/):"
        echo "  Before: ${INITIAL_ROOT_USED}GB used, ${INITIAL_ROOT_AVAIL}GB available"
        echo "  After:  ${FINAL_ROOT_USED}GB used, ${FINAL_ROOT_AVAIL}GB available"
        echo "  Freed:  ${ROOT_FREED}GB"
        echo ""
        
        if [[ "$MERGE_DISKS" == "true" ]]; then
          WORKSPACE_AVAIL=$(df /home/runner/work --output=avail -BG | tail -1 | tr -d ' G')
          WORKSPACE_SIZE=$(df /home/runner/work --output=size -BG | tail -1 | tr -d ' G')
          echo "Merged workspace (/home/runner/work):"
          echo "  Total size: ${WORKSPACE_SIZE}GB"
          echo "  Available:  ${WORKSPACE_AVAIL}GB"
          echo ""
          echo "Combined from:"
          echo "  - Loopback from root (~${ROOT_FREED}GB * 80%)"
          echo "  - /mnt disk (~${INITIAL_MNT_AVAIL:-74}GB)"
        fi
        
        echo ""
        echo "============================================"
        echo "  rmrf complete!"
        echo "============================================"
